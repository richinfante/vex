#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    check_expander, sensorNone)
#pragma config(Sensor, in2,    lightSensor,    sensorReflection)
#pragma config(Sensor, in3,    lightSensor2,   sensorReflection)
#pragma config(Sensor, in4,    armTilt,        sensorPotentiometer)
#pragma config(Sensor, in5,    bigBallP,       sensorPotentiometer)
#pragma config(Sensor, in7,    armDegrees,     sensorPotentiometer)
#pragma config(Sensor, in8,    autoSwitch,     sensorPotentiometer)
#pragma config(Sensor, dgtl10, killSwitch,     sensorTouch)
#pragma config(Sensor, dgtl11, Wait,           sensorTouch)
#pragma config(Sensor, dgtl12, deployArm,      sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftBigBall,   tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           armLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           intakeLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intakeRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightBigBall,  tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftFrontMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static int bigBallUpperLimit = 197;//123;
static int bigBallLowerLimit = 1;//200;

static int armLowerLimit = 35;
static int armUpperLimit = 115;




#include "VEX_COMPETITION_INCLUDES.c"
#include "IntegratedMotor.h"
#include "BigBallGrabber.h"
#include "LCDScreen.h"
/**
* Notes:
*
* This file accomplishes 100% of what the old code did, in far less code.
* It works better -- Yes it does!
* It works really good!
*
*
*/


void deployRobotArm()
{
    //1 indicates the closed position
    SensorValue[deployArm] = 1;
}


void pre_auton() {
    //clear encoders
    clearEncoder(rightMotor);
    clearEncoder(leftMotor);
}

void setLiftSpeed(int speed) {
    motor[armRight] = speed;
    motor[armLeft] = speed;
}



/**
* Sensor s, is linked to tMotor, r
* reqspeed is the speed requested,
* low is the sensor low limit
* high is the sensor high limit
* link is a integer value +-1, which changes
*
* @return was stop forced?
*
*/
bool linkMotor(tSensors s, tMotor linkedMotor,int reqspeed, int low, int high, int link = 1) {
    int sensorDegrees = getPotentiometerDegrees(s);
    //(int) ((float) SensorValue(s) / (float) 4075 * (float) 270);
    //if we are under low, and also the speed is greater than 0, so we would **increase** the sensor
    if(sensorDegrees < low ) {
        //motor is valid
        if(reqspeed * link > 0) {
            motor[linkedMotor] = link*reqspeed;
        }else {
            motor[linkedMotor] = 0;
            return true;
        }
    }
    //if we are above high, and also the speed is less than 0, so we would **decrease** the sensor
    else if(sensorDegrees > high) {
        //motor is valid
        if(reqspeed * link < 0) {
            motor[linkedMotor] = link*reqspeed;
        }else{
            motor[linkedMotor] = 0;
            return true;
        }
    }
    //otherwise, we are not allowed to do this
    else{
        motor[linkedMotor] =link* reqspeed;
    }
    return false;
}

/**
* Checks positiveButton and negative button for presses
* sets motor m, to 127 or -127 accordingly, respecting limits and links to sensor, s.
*/
void linkController(int positiveButton, int negativeButton, tSensors s, tMotor m, int low, int high, int link = 1) {
    int speed = (vexRT[positiveButton] ==1 ) ? FORWARD : ((vexRT[negativeButton] == 1) ? REVERSE : OFF);
    linkMotor(s,m,speed, low,high,link);
}

/**
* Moves the linked motor, to target.
* int speed is a positive integer which describes how fast the motor should move
*/
void moveLinkedMotor(tSensors s, tMotor linkedMotor, int speed, int low, int high, int target, int link = 1) {

    speed = 127;
    //if the target < currentPos
    if(target < getPotentiometerDegrees(s)) {
        //reverse speed
        speed *= link * -abs(speed);
        //set low target
        low = target;
    }else {
        //set high target
        high = target;
        speed = link * abs(speed);
    }
    //link motor while it is not stopped
    while(!linkMotor(s,linkedMotor, speed, low, high, link));
    motor[linkedMotor] = 0;
}

void moveLinkedMotors(tSensors s, tMotor linkedMotor, tMotor mirroredMotor, int speed, int low, int high, int target, int link = 1) {
    speed = 127;
    //if the target < currentPos
    if(target < getPotentiometerDegrees(s)) {
        //reverse speed
        speed *= link * -abs(speed);
        //set low target
        low = target;
    }else {
        //set high target
        high = target;
        speed = link * abs(speed);
    }
    //link motor while it is not stopped
    bool reached = true;
    while(reached){
        motor[mirroredMotor] = link * speed;
        reached = !linkMotor(s, linkedMotor, speed, low, high, link);

    }

    motor[linkedMotor] = 0;
    motor[mirroredMotor] = 0;
}

/**
* Moves Motor m, to speed.
*/
void moveMotor(tMotor m, int reqspeed) {
    motor[m] = reqspeed;
}

/**
* Checks positiveButton and negative button for presses
* sets motor m, to 127 or -127 accordingly
*/
void linkController(int positiveButton, int negativeButton,  tMotor m) {
    int speed = (vexRT[positiveButton] ==1 ) ? FORWARD : ((vexRT[negativeButton] == 1) ? REVERSE : OFF);
    moveMotor(m, speed);
}

/**
* Threshold to >(+/-)25
*/
int thresh(int speed) {
    //return zero if the absolute value of  speed - 0 is less than 10
    return (abs(speed) < 25) ? 0: speed;
}

/**
* Xbox controller
*/
void dVexControl(int speed, int steer) {
    //apply thresholds to raw joystick values
    speed = thresh(speed);
    steer = thresh(steer);

    //apply difference to each side to account for flipped motors
    motor[leftMotor] =  (speed + steer);
    motor[rightMotor] =(speed - steer);

    //apply master wheel speeds to front wheel speeds
    motor[leftFrontMotor] = motor[rightMotor];
    motor[rightFrontMotor] = motor[leftMotor];
}

/**
_____         _
|_   _|_ _ ___| | _____
| |/ _` / __| |/ / __|
| | (_| \__ \   <\__ \
|_|\__,_|___/_|\_\___/

*/

task detachedLiftTask() {
    /**
	* Yikes! needs much calibraton
	*/
    //lower big ball grabber
    //moveLinkedMotors(bigBallP, leftBigBall, rightBigBall,127, bigBallLoweLimit, bigBallUpperLimit, bigBallLowerLimit);
    //moveLinkedMotors(armDegrees, armRight, armLeft,127, armLowerLimit, armUpperLimit, armUpperLimit);
}

/**
 * Wait For user and display message
 */
void wait(){
    //clear
    clearLCDLine(1);
    //displat
    displayLCDString(1, 0, "Waiting... ");
    //wait
    while(SensorValue(Wait)!=1){}
    //clear
    clearLCDLine(1);
    //display
    displayLCDString(1, 0, "Running... ");
}


task autonomous() {
    clearDebugStream();
    //flags and counters
    int autonomous = 0;
    bool pressed = false;

    //clear lcd
    clearLCD();

    //light backlight
    bLCDBacklight = true;

    //loop until a user confirms selection
    while(SensorValue(Wait)!=1) {
        //make lcd not autoclear
        isLCDDirty = false;

        //second button
        if(!pressed && nLCDButtons == 2)
        {
            //clear
            clearLCDLine(0);
            //increase id
            autonomous++;
            //set pressed
            pressed =  true;

        }
        //first button
        else if(!pressed && nLCDButtons == 1)
        {
            //clear
            clearLCDLine(0);
            //if autonomous>0 decrease autonomous
            if(autonomous>0)
                autonomous--;
            //set button pressed
            pressed =  true;
        }
        //no buttons
        else if(pressed && nLCDButtons == 0)
        {
            pressed = false;
        }
        //display the autonomous number and ui controls
        displayLCDString(0, 0, "Autonomous: ");
        string number;
        sprintf(number, "%d", autonomous);
        displayNextLCDString(number);
        displayLCDString(1, 0, "----  ++++");
    }
    //light the backlight
    bLCDBacklight = true;

    //display running message
    clearLCDLine(1);
    displayLCDString(1, 0, "Running... ");

    //wait 2 sec so it dosent look like we are cheating
    wait1Msec(2000);

    //deploy
    deployRobotArm();
/**
0 : Red Middle Zone
1 : Blue Middle Zone
2 : Red Hanging Zone
**/

    //run autonomous 0
    if(autonomous == 0 || autonomous == 1)
    {

    driveInches(REVERSE, 70);
    moveLinkedMotors(armDegrees, armLeft, armRight,127, armLowerLimit, armUpperLimit, armUpperLimit);
    _motor(intakeLeft,127);
    _motor(intakeRight,127);
    wait1Msec(1000);
        _motor(intakeLeft,0);
    _motor(intakeRight,0);
     moveLinkedMotors(armDegrees, armLeft, armRight, 127,armLowerLimit, armUpperLimit, armLowerLimit);
       driveInches(FORWARD, 70);
       wait();
    	driveTiles(FORWARD, .2);
        moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,80);
        moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,1);
        wait();
        driveTiles(FORWARD, 1);
        turnDegrees(((autonomous == 0) ? LEFT : RIGHT), 75);
        driveTiles(FORWARD, .1);
        moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,80);
        moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,1);
        //turnDegrees(LEFT, 35);
       // driveTiles(FORWARD,.4);
        wait();

        //driveTiles(REVERSE, .5);
    }else if(autonomous == 2){
 				driveTiles(FORWARD,.8);
 				driveTiles(REVERSE,.8);
    		moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,180);
				driveTiles(FORWARD,.5);
			   moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,40);
				moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,180);
				driveTiles(FORWARD,.5);
					moveLinkedMotors(bigBallP, leftBigBall,rightBigBall,127, bigBallLowerLimit, bigBallUpperLimit,40);
				startHoldingBalls();
				turnDegrees(RIGHT, 90);
				driveTiles(REVERSE, 3);
	}


    //display done message
    clearLCDLine(1);
    displayLCDString(1, 0, "Done! ");
}

task usercontrol() {
    while(true){

        //if first button set piston
        if(nLCDButtons==1)
        {
            SensorValue[deployArm] = 0;
        }
        //if last button set piston
        else if(nLCDButtons==4)
        {
            SensorValue[deployArm] = 1;
        }
        //display battery status
        else if(nLCDButtons == 2)
        {
            displayBatteryStatus();
        }
        //clear the lcd
        else if(isLCDDirty)
        {
            clearLCD();
        }
        //apply motor values
        dVexControl(vexRT[Ch3], vexRT[Ch1]);

        //arm button presses
        linkController(Btn8U, Btn8D, armDegrees, armLeft, armLowerLimit, armUpperLimit);
        linkController(Btn8U, Btn8D, armDegrees, armRight, armLowerLimit, armUpperLimit);

        //intake\\
        linkController(Btn6U, Btn6D, intakeLeft);
        linkController(Btn6U, Btn6D, intakeRight);


        //big ball
        linkController(Btn5D, Btn5U, bigBallP, leftBigBall, bigBallLowerLimit, bigBallUpperLimit);
        linkController(Btn5D, Btn5U, bigBallP, rightBigBall, bigBallLowerLimit, bigBallUpperLimit);

    }
}
