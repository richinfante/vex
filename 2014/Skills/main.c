#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    check_expander, sensorAnalog)
#pragma config(Sensor, in2,    lightSensor,    sensorReflection)
#pragma config(Sensor, in3,    lightSensor2,   sensorReflection)
#pragma config(Sensor, in4,    armTilt,        sensorPotentiometer)
#pragma config(Sensor, in5,    bigBallP,       sensorPotentiometer)
#pragma config(Sensor, in7,    armDegrees,     sensorPotentiometer)
#pragma config(Sensor, in8,    autoSwitch,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftUpArm,      sensorTouch)
#pragma config(Sensor, dgtl2,  leftDownArm,    sensorTouch)
#pragma config(Sensor, dgtl3,  rightUpArm,     sensorTouch)
#pragma config(Sensor, dgtl4,  rightDownArm,   sensorTouch)
#pragma config(Sensor, dgtl10, killSwitch,     sensorTouch)
#pragma config(Sensor, dgtl11, Wait,           sensorTouch)
#pragma config(Sensor, dgtl12, deployArm,      sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftBigBall,   tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           intakeLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intakeRight,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightBigBall,  tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           leftFrontMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
.____             __ _                       _   _
/ ___|___  _ __  / _(_) __ _ _   _ _ __ __ _| |_(_) ___  _ __
| |   / _ \| '_ \| |_| |/ _` | | | | '__/ _` | __| |/ _ \| '_ \
| |__| (_) | | | |  _| | (_| | |_| | | | (_| | |_| | (_) | | | |
\____\___/|_| |_|_| |_|\__, |\__,_|_|  \__,_|\__|_|\___/|_| |_|

*/
//Default Vex Code
static int bigBallUpperLimit = 197;//123;
static int bigBallLowerLimit = 1;//200;

static int armLowerLimit = 35;
static int armUpperLimit = 115;

#include "Vex_Competition_Includes.c"
#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


static int upLimit = 123;
static int downLimit = 200;
#define useArm
#include "IntegratedMotor.h"
#include "BigBallGrabber.h"
/**
* Arm limits
*/
/*
__  __ _              _____                 _   _
|  \/  (_)___  ___    |  ___|   _ _ __   ___| |_(_) ___  _ __  ___
| |\/| | / __|/ __|   | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
| |  | | \__ \ (__ _  |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
|_|  |_|_|___/\___(_) |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

*/



/**
* Wait for button push
*/
void wait()
{
	while(SensorValue[Wait]!=1){}
}

/**
*Set the speed of the lift
*/

void setLiftSpeed(int speed)
{
	motor[armRight] = speed;
	motor[armLeft] = speed;
}

/**
.   _         _                                                _            _
.  / \  _   _| |_ ___  _ __   ___  _ __ ___   ___  _   _ ___  | |_ __ _ ___| | __
. / _ \| | | | __/ _ \| '_ \ / _ \| '_ ` _ \ / _ \| | | / __| | __/ _` / __| |/ /
./ ___ \ |_| | || (_) | | | | (_) | | | | | | (_) | |_| \__ \ | || (_| \__ \   <
/_/   \_\__,_|\__\___/|_| |_|\___/|_| |_| |_|\___/ \__,_|___/  \__\__,_|___/_|\_\
*/

void pre_auton(){
	clearEncoder(rightMotor);
	clearEncoder(leftMotor);
}

void deployRobotArm()
{
	SensorValue[deployArm] = 1;
	wait1Msec(1111);
	SensorValue[deployArm] = 0;
	wait1Msec(1000);
	//writeDebugStreamLine("arm%d",getPotentiometerDegrees(armTilt));
	SensorValue[deployArm] = 1;
	wait1Msec(1111);
	SensorValue[deployArm] = 0;

	flipTo(DOWN, downLimit);
}


task autonomous(){
	clearDebugStream();
	deployRobotArm();

	//startHoldingBalls();
	Direction turnDirection = LEFT;
	//get the two big balls
	{
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, .5);
		flipTo(UP, upLimit - 70);
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, .6);
		startHoldingBalls();

		wait1Msec(800);
		driveTiles(FORWARD, .5);//was .5
		driveTiles(REVERSE, .5); //same here
		//	turnDegrees(RIGHT_SLOW, 90);
		//	driveInches(REVERSE, 5);
		//	turnDegrees(LEFT_SLOW, 90);
		driveTiles(REVERSE, 1.5);
	}

	//wait for user to turn: BACK TO BUMP.
	wait();

	//score 3 big balls, turn 90 degrees after and raise arm.
	{


#ifndef useArm

		driveTiles(REVERSE, 2.5);
		stopHoldingBalls();
		setFlip(UP, 1000);
		driveTiles(REVERSE,.6);
		driveTiles(FORWARD, 1.5);

#else
		driveTiles(REVERSE, 2);

		setLiftSpeed(UP);
		wait1Msec(800);
		stopHoldingBalls();
		wait1Msec(1400-800);
		setLiftSpeed(DOWN);
		wait1Msec(1000);
		setLiftSpeed(OFF);
		flipTo(UP,upLimit- 80);
		driveTiles(FORWARD, 1.5 - .6);


#endif

		turnDegrees(turnDirection, 90);
	}


	//score 2 big balls off rail and position facing other 2
	{

		//perp
		driveTiles(FORWARD, 1);
		//ttbar
		turnDegrees(turnDirection, 95);
		//go
		driveTiles(FORWARD, .2);

		//hit first ball
		setFlip(DOWN, 800);
		setFlip(UP, 800);

		//back
		driveTiles(REVERSE, .3);

		//turn and drive into position to hit next
		turnDegrees(-turnDirection, 80);
		//perp
		driveTiles(FORWARD, 2);

		//drive forward to hit
		turnDegrees(turnDirection, 90);
		//go
		driveTiles(FORWARD, .4);

		//hit second ball
		setFlip(DOWN, 800);
		setFlip(UP, 800);
		//back
		driveTiles(REVERSE, .4);

		//turn and drive into position to hit next
		turnDegrees(-turnDirection, 80);
		driveTiles(REVERSE, 2);
		turnDegrees(turnDirection, 90);
		driveTiles(REVERSE, 1.3);//was 1.5 then 1.4
		turnDegrees(-turnDirection, 90+9);
	}

	//get the two big balls
	{
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, 1);
		flipTo(UP, upLimit-60);
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, 1.15);
		startHoldingBalls();
		wait1Msec(1000);
		driveTiles(REVERSE, 1);


		turnDegrees(-turnDirection, 90);

		driveTiles(REVERSE, .2);


		//turnDegrees(turnDirection, 90);

	}
	//wait();
	//score 2 big balls
	{

#ifdef useArm
		driveTiles(REVERSE, 2.3);

		setLiftSpeed(UP);
		wait1Msec(800);
		stopHoldingBalls();
		wait1Msec(1400-800);
		setLiftSpeed(DOWN);
		wait1Msec(1000);
		setLiftSpeed(OFF);
		flipTo(UP,upLimit- 80);
		//	driveTiles(FORWARD, 1.5 - .6);


#endif


		driveTiles(FORWARD, .4);


		turnDegrees(turnDirection, 90);

		driveTiles(FORWARD, 2);

		turnDegrees(turnDirection, 90);
		driveTiles(FORWARD, .4);


		//hit second ball
		setFlip(DOWN, 800);
		setFlip(UP, 800);
		//back
		//		driveTiles(REVERSE, .4);

	}
}
/*
____            _        ____       _       _                ____            _             _
| __ )  __ _ ___(_) ___  |  _ \ _ __(_)_   _(_)_ __   __ _   / ___|___  _ __ | |_ _ __ ___ | |___
|  _ \ / _` / __| |/ __| | | | | '__| \ \ / / | '_ \ / _` | | |   / _ \| '_ \| __| '__/ _ \| / __|
| |_) | (_| \__ \ | (__  | |_| | |  | |\ V /| | | | | (_| | | |__| (_) | | | | |_| | | (_) | \__ \
|____/ \__,_|___/_|\___| |____/|_|  |_| \_/ |_|_| |_|\__, |  \____\___/|_| |_|\__|_|  \___/|_|___/

*/


/**
* Sensor s, is linked to tMotor, r
* reqspeed is the speed requested,
* low is the sensor low limit
* high is the sensor high limit
* link is a integer value +-1, which changes
*
* @return was stop forced?
*
*/
bool linkMotor(tSensors s, tMotor linkedMotor,int reqspeed, int low, int high, int link = 1) {
    int sensorDegrees = getPotentiometerDegrees(s);
    //(int) ((float) SensorValue(s) / (float) 4075 * (float) 270);
    //if we are under low, and also the speed is greater than 0, so we would **increase** the sensor
    if(sensorDegrees < low ) {
        //motor is valid
        if(reqspeed * link > 0) {
            motor[linkedMotor] = link*reqspeed;
        }else {
            motor[linkedMotor] = 0;
            return true;
        }
    }
    //if we are above high, and also the speed is less than 0, so we would **decrease** the sensor
    else if(sensorDegrees > high) {
        //motor is valid
        if(reqspeed * link < 0) {
            motor[linkedMotor] = link*reqspeed;
        }else{
            motor[linkedMotor] = 0;
            return true;
        }
    }
    //otherwise, we are not allowed to do this
    else{
        motor[linkedMotor] =link* reqspeed;
    }
    return false;
}

/**
* Checks positiveButton and negative button for presses
* sets motor m, to 127 or -127 accordingly, respecting limits and links to sensor, s.
*/
void linkController(int positiveButton, int negativeButton, tSensors s, tMotor m, int low, int high, int link = 1) {
    int speed = (vexRT[positiveButton] ==1 ) ? FORWARD : ((vexRT[negativeButton] == 1) ? REVERSE : OFF);
    linkMotor(s,m,speed, low,high,link);
}

/**
* Moves the linked motor, to target.
* int speed is a positive integer which describes how fast the motor should move
*/
void moveLinkedMotor(tSensors s, tMotor linkedMotor, int speed, int low, int high, int target, int link = 1) {

    speed = 127;
    //if the target < currentPos
    if(target < getPotentiometerDegrees(s)) {
        //reverse speed
        speed *= link * -abs(speed);
        //set low target
        low = target;
    }else {
        //set high target
        high = target;
        speed = link * abs(speed);
    }
    //link motor while it is not stopped
    while(!linkMotor(s,linkedMotor, speed, low, high, link)){}
    motor[linkedMotor] = 0;
}

void moveLinkedMotors(tSensors s, tMotor linkedMotor, tMotor mirroredMotor, int speed, int low, int high, int target, int link = 1) {
    speed = 127;
    //if the target < currentPos
    if(target < getPotentiometerDegrees(s)) {
        //reverse speed
        speed *= link * -abs(speed);
        //set low target
        low = target;
    }else {
        //set high target
        high = target;
        speed = link * abs(speed);
    }
    //link motor while it is not stopped
    bool reached = true;
    while(reached){
        motor[mirroredMotor] = link * speed;
        reached = !linkMotor(s, linkedMotor, speed, low, high, link);

    }

    motor[linkedMotor] = 0;
    motor[mirroredMotor] = 0;
}

/**
* Moves Motor m, to speed.
*/
void moveMotor(tMotor m, int reqspeed) {
    motor[m] = reqspeed;
}

/**
* Checks positiveButton and negative button for presses
* sets motor m, to 127 or -127 accordingly
*/
void linkController(int positiveButton, int negativeButton,  tMotor m) {
    int speed = (vexRT[positiveButton] ==1 ) ? FORWARD : ((vexRT[negativeButton] == 1) ? REVERSE : OFF);
    moveMotor(m, speed);
}



/**
* User Control. only driving is supported to save code size.
*/

int thresh(int speed)
{
	//return zero if the absolute value of  speed - 0 is less than 10
return (abs(speed) < 25) ? 0: speed;
}

/**
*	User controller joysticks
*/

void dVexControl(int speed, int steer)
{
	//apply thresholds to raw joystick values
	speed = thresh(speed);
	steer = thresh(steer);

	//apply difference to each side to account for flipped motors
	motor[leftMotor] =  (speed + steer);//*steeringTrim;
	motor[rightMotor] =(speed - steer);//*steeringTrim;

	//apply master wheel speeds to front wheel speeds
	motor[leftFrontMotor] = motor[rightMotor];
	motor[rightFrontMotor] = motor[leftMotor];
}


task usercontrol(){
	while(true)
	{
		dVexControl(vexRT[Ch3], vexRT[Ch1]);


        //arm button presses
        linkController(Btn8U, Btn8D, armDegrees, armLeft, armLowerLimit, armUpperLimit);
        linkController(Btn8U, Btn8D, armDegrees, armRight, armLowerLimit, armUpperLimit);

        //intake
        linkController(Btn6U, Btn6D, intakeLeft);
        linkController(Btn6U, Btn6D, intakeRight);


        //big ball
        linkController(Btn5D, Btn5U, bigBallP, leftBigBall, bigBallLowerLimit, bigBallUpperLimit);
        linkController(Btn5D, Btn5U, bigBallP, rightBigBall, bigBallLowerLimit, bigBallUpperLimit);
	}
}
