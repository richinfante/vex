#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    check_expander, sensorAnalog)
#pragma config(Sensor, in2,    lightSensor,    sensorReflection)
#pragma config(Sensor, in3,    lightSensor2,   sensorReflection)
#pragma config(Sensor, in4,    armTilt,        sensorPotentiometer)
#pragma config(Sensor, in5,    bigBallP,       sensorPotentiometer)
#pragma config(Sensor, in7,    armDegrees,     sensorPotentiometer)
#pragma config(Sensor, in8,    autoSwitch,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftUpArm,      sensorTouch)
#pragma config(Sensor, dgtl2,  leftDownArm,    sensorTouch)
#pragma config(Sensor, dgtl3,  rightUpArm,     sensorTouch)
#pragma config(Sensor, dgtl4,  rightDownArm,   sensorTouch)
#pragma config(Sensor, dgtl10, killSwitch,     sensorTouch)
#pragma config(Sensor, dgtl11, Wait,           sensorTouch)
#pragma config(Sensor, dgtl12, deployArm,      sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           leftBigBall,   tmotorVex269, openLoop)
#pragma config(Motor,  port4,           armLeft,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           intakeLeft,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           armRight,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           intakeRight,   tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightBigBall,  tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port9,           leftFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*
.____             __ _                       _   _
/ ___|___  _ __  / _(_) __ _ _   _ _ __ __ _| |_(_) ___  _ __
| |   / _ \| '_ \| |_| |/ _` | | | | '__/ _` | __| |/ _ \| '_ \
| |__| (_) | | | |  _| | (_| | |_| | | | (_| | |_| | (_) | | | |
\____\___/|_| |_|_| |_|\__, |\__,_|_|  \__,_|\__|_|\___/|_| |_|

*/
//Default Vex Code
#include "Vex_Competition_Includes.c"
#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


static int upLimit = 123;
static int downLimit = 200;
#define useArm
#include "IntegratedMotor.h"
#include "BigBallGrabber.h"
/**
* Arm limits
*/
/*
__  __ _              _____                 _   _
|  \/  (_)___  ___    |  ___|   _ _ __   ___| |_(_) ___  _ __  ___
| |\/| | / __|/ __|   | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
| |  | | \__ \ (__ _  |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
|_|  |_|_|___/\___(_) |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

*/

/**
* Wait for button push
*/
void wait()
{
	while(SensorValue[Wait]!=1){}
}

/**
*Set the speed of the lift
*/

void setLiftSpeed(int speed)
{
	motor[armRight] = speed;
	motor[armLeft] = speed;
}

/**

.   _         _                                                _            _
.  / \  _   _| |_ ___  _ __   ___  _ __ ___   ___  _   _ ___  | |_ __ _ ___| | __
. / _ \| | | | __/ _ \| '_ \ / _ \| '_ ` _ \ / _ \| | | / __| | __/ _` / __| |/ /
./ ___ \ |_| | || (_) | | | | (_) | | | | | | (_) | |_| \__ \ | || (_| \__ \   <
/_/   \_\__,_|\__\___/|_| |_|\___/|_| |_| |_|\___/ \__,_|___/  \__\__,_|___/_|\_\


*/

void pre_auton(){
	clearEncoder(rightMotor);
	clearEncoder(leftMotor);
}


task autonomous(){
	clearDebugStream();

	//startHoldingBalls();
	Direction turnDirection = LEFT;
	//get the two big balls
	{
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, .5);
		flipTo(UP, upLimit - 70);
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, .6);
		startHoldingBalls();

		wait1Msec(800);
		driveTiles(FORWARD, .5);//was .5
		driveTiles(REVERSE, .5); //same here
		//	turnDegrees(RIGHT_SLOW, 90);
		//	driveInches(REVERSE, 5);
		//	turnDegrees(LEFT_SLOW, 90);
		driveTiles(REVERSE, 1.5);
	}

	//wait for user to turn: BACK TO BUMP.
	wait();

	//score 3 big balls, turn 90 degrees after and raise arm.
	{


#ifndef useArm

		driveTiles(REVERSE, 2.5);
		stopHoldingBalls();
		setFlip(UP, 1000);
		driveTiles(REVERSE,.6);
		driveTiles(FORWARD, 1.5);

#else
		driveTiles(REVERSE, 2);

		setLiftSpeed(UP);
		wait1Msec(800);
		stopHoldingBalls();
		wait1Msec(1400-800);
		setLiftSpeed(DOWN);
		wait1Msec(1000);
		setLiftSpeed(OFF);
		flipTo(UP,upLimit- 80);
		driveTiles(FORWARD, 1.5 - .6);


#endif

		turnDegrees(turnDirection, 90);
	}


	//score 2 big balls off rail and position facing other 2
	{

		//perp
		driveTiles(FORWARD, 1.3);
		//ttbar
		turnDegrees(turnDirection, 95);
		//go
		driveTiles(FORWARD, .2);

		//hit first ball
		setFlip(DOWN, 800);
		setFlip(UP, 800);

		//back
		driveTiles(REVERSE, .3);

		//turn and drive into position to hit next
		turnDegrees(-turnDirection, 80);
		//perp
		driveTiles(FORWARD, 1.7);

		//drive forward to hit
		turnDegrees(turnDirection, 90);
		//go
		driveTiles(FORWARD, .4);

		//hit second ball
		setFlip(DOWN, 800);
		setFlip(UP, 800);
		//back
		driveTiles(REVERSE, .4);

		//turn and drive into position to hit next
		turnDegrees(-turnDirection, 90);
		driveTiles(REVERSE, 2);
		turnDegrees(turnDirection, 90);
		driveTiles(REVERSE, 1.4);//was 1.5
		turnDegrees(-turnDirection, 90+9);
	}

	//get the two big balls
	{
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, 1);
		flipTo(UP, upLimit-60);
		flipTo(DOWN, downLimit);
		driveTiles(FORWARD, 1.15);
		startHoldingBalls();
		wait1Msec(1000);
		//driveTiles(REVERSE, 1);


		turnDegrees(-turnDirection, 180);

		driveTiles(REVERSE, .5);

		turnDegrees(turnDirection, 90);

		driveTiles(REVERSE, .2);


		//turnDegrees(turnDirection, 90);

	}
	//wait();
	//score 2 big balls
	{

#ifdef useArm
		driveTiles(REVERSE, 2.3);

		setLiftSpeed(UP);
		wait1Msec(800);
		stopHoldingBalls();
		wait1Msec(1400-800);
		setLiftSpeed(DOWN);
		wait1Msec(1000);
		setLiftSpeed(OFF);
		flipTo(UP,upLimit- 80);
		//	driveTiles(FORWARD, 1.5 - .6);


#endif

/*
		driveTiles(FORWARD, .4);


		turnDegrees(turnDirection, 90);

		driveTiles(FORWARD, 2);

		turnDegrees(turnDirection, 90);
		driveTiles(FORWARD, .4);

*/
		//hit second ball
		setFlip(DOWN, 800);
		setFlip(UP, 800);
		//back
		//		driveTiles(REVERSE, .4);

	}
}
/*
____            _        ____       _       _                ____            _             _
| __ )  __ _ ___(_) ___  |  _ \ _ __(_)_   _(_)_ __   __ _   / ___|___  _ __ | |_ _ __ ___ | |___
|  _ \ / _` / __| |/ __| | | | | '__| \ \ / / | '_ \ / _` | | |   / _ \| '_ \| __| '__/ _ \| / __|
| |_) | (_| \__ \ | (__  | |_| | |  | |\ V /| | | | | (_| | | |__| (_) | | | | |_| | | (_) | \__ \
|____/ \__,_|___/_|\___| |____/|_|  |_| \_/ |_|_| |_|\__, |  \____\___/|_| |_|\__|_|  \___/|_|___/

*/

/**
* User Control. only driving is supported to save code size.
*/

int thresh(int speed)
{
	//return zero if the absolute value of  speed - 0 is less than 10
return (abs(speed) < 25) ? 0: speed;
}

/**
*	User controller joysticks
*/

void dVexControl(int speed, int steer)
{
	//apply thresholds to raw joystick values
	speed = thresh(speed);
	steer = thresh(steer);

	//apply difference to each side to account for flipped motors
	motor[leftMotor] =  (speed + steer);//*steeringTrim;
	motor[rightMotor] =(speed - steer);//*steeringTrim;

	//apply master wheel speeds to front wheel speeds
	motor[leftFrontMotor] = motor[rightMotor];
	motor[rightFrontMotor] = motor[leftMotor];
}


task usercontrol(){
	while(true)
	{
		dVexControl(vexRT[Ch3], vexRT[Ch1]);
	}
}
